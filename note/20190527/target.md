### JEP 286: 局部变量类型推断
```$xslt
    Author	Brian Goetz
    Owner	Dan Smith
    Type	Feature
    Scope	SE
    Status	Closed / Delivered
    Release	10
    Component	tools
    Discussion	amber dash dev at openjdk dot java dot net
    Effort	M
    Duration	S
    Relates to	JEP 323: Local-Variable Syntax for Lambda Parameters
        JEP 301: Enhanced Enums
    Reviewed by	Alex Buckley, Mark Reinhold
    Endorsed by	Mark Reinhold
    Created	2016/03/08 15:37
    Updated	2018/10/12 01:28
    Issue	8151454
```
### 摘要
    增强Java语言以使用初始值设定项将类型推断扩展为局部变量的定义。
### 目标
     我们通过减少与编写Java代码相关的编程范式来寻求改善开发者的使用体验，同时保持Java对静态类型安全的承诺,
     允许开发人员忽略一些往往没有必要的局部变量类型的显式定义。这种特性将会被允许，举个例子，
     可以使用以下方式定义变量：
```$xslt
        var list = new ArrayList<String>();  // 指定list变量为ArrayList<String>类型
        var stream = list.stream();          // 指定stream变量为Stream<String>类型
```
     这种处理方式将局限于可以初始化值的局部变量、增强的for循环中的索引、以及传统for循环内定义的变量；它不适用于
     方法形式、构造函数形式、方法返回类型、字段、catch形式或其他任意类型的变量定义。
### 成功的标准
    定量上，我们希望实际代码库中的大部分局部变量定义都能够使用此特性转换，进而推断出合适的类型。
    
    定性上， 我们希望局部变量类型推断的局限性，以及这些限制的动机，可以供普通用户访问。(当然，这通常是不可能实现的
    ；我们不仅无法推断出所有局部变量的合理类型，而且有些用户认为类型推断是一种脑海里阅读的形式，而不是一种约束求解的算法，
    在这种情况下，任何解释似乎都不是明智的。)，不过我们试图以这样的方式绘制线条，以便可以清楚地说明为什么某个特定
    的构造会在线上，并且以这种方式，编译器可以有效地联系到用户代码的复杂性，而不是语言上的任意限制。
### 动机
    开发者经常抱怨Java中所需的样板编码程度。本地的一些很明显的类型定义通常被认为是没有必要的，甚至还有妨碍；给出良好的
    变量命名，通常很清楚这个变量做了什么。
    
    为每个变量提供一个清楚的类型的需要也意外地鼓励开发者使用过于复杂的表达式；而使用较低的编程范式定义语言，将复杂的链式
    或嵌套式表达式分解为更简单的表达式的可能性更小。
    
    几乎所有其他流行的静态类型 "{}" 语言，无论是否在JVM上，都已经支持某些形式的局部变量类型推断：C++ (auto),C# (var)
    ,Scala (var/val),Go (用 := 定义)。Java几乎是唯一一种没有采用局部变量类型推断的流行的静态类型语言；在这一点上，这应该
    不再是一个有争议的特性。
    
    在Java SE 8中，类型推断的范围显著被放宽，包括嵌套和链式泛型方法调用的推断扩展，和lambda形式的推断。这使得构建用于
    调用链的API变得容易得多，而这样的API(如 Streams)非常流行，这些都已经表明开发者已经习惯推断出中间类型。比如在下面的
    链式调用中：
```$xslt
        int maxWeight = blocks.stream()
                      .filter(b -> b.getColor() == BLUE)
                      .mapToInt(Block::getWeight)
                      .max();
```
    没有人会困扰到(或者注意到)中间类型Stream<Block> 和 IntStream，以及lambda表达式中变量b的类型，也不会在源程序中明确
    显示。    
    
    局部变量类型推断允许在结构不太紧密的API中产生类似的效果；局部变量基本都用在链式调用上，并从类型推断上获益，例如：
```$xslt
        var path = Paths.get(fileName);
        var bytes = Files.readAllBytes(path);
``` 
### 描述  
    对于使用初始化值的局部变量定义、增强for循环里的索引、和在传统for循环中定义的索引变量，允许它们接受保留类型名称var来
    代替显示的变量类型：
```$xslt
        var list = new ArrayList<String>(); // infers ArrayList<String>
        var stream = list.stream();         // infers Stream<String>
```
    标识符var不是关键字，而是一个保留类型名称。这意味着可以使用var作为变量、方法或包名称的代码不会受到影响；使用var作为
    类或接口名称的代码将受到影响（不过这些名称在实际情况中很少见，因为它们违反了通常的命名惯例）。
    
    缺少初始化值的局部变量定义的形式、定义多个变量，有额外的数组维度符号[]、或引用正在初始化的变量，这些都是不被允许的。
    拒绝未初始化值的局部变量会缩小这个特性的作用范围，避免"action at distance"推断错误，在典型的程序中仅仅只排除了一小
    部分的局部变量。
    
    推断过程基本上只给变量赋予其初始化表达式的类型。另外还有一些要注意的：
    
*  初始化程序没有目标类型（因为我们还没有推断出来）。需要这种类型的Poly表达式，如lambda表达式、方法引用和数组初始化值，会
    引起错误。    
*  如果初始化值具有null类型，会引发错误，就像没有初始化值的变量一样，这个变量可能稍后要进行初始化，但我们还不知道想要什
    么类型。
*  捕获变量和内嵌的捕获变量，会被映射到没有涉及到捕获变量的超类型上。这种映射将捕获变量替换为其上界，用有界通配符替换
    涉及到捕获变量的类型参数。（然后不断重复）。这保留了传统的捕获变量的限制范围，这些变量仅在单个语句中考虑。
*   除上述例外情况外，不可表示的类型、包括匿名类类型和交集类型，可以被推断出来。编译器以及编译工具需要考虑这种可能性。

### 适用性和影响力
    通过浏览OpenJDK代码库来查看局部变量的定义，我们发现13%的局部变量不能使用var编写，因为它们没有初始化值、初始化的值是
    null类型、或者在初始化的时候很少需要目标类型。在剩余的局部变量定义中：
*  无论如何，具有初始化值的局部变量大多数（在JDK和更广泛的语法库中超过75%）已经是有效不变的，意味着任何"推动"远离这个特性
    提供的可变性都会受到限制。 
*   lambdas/内部类的可捕获性已经为有效final变量提供了重要的推动。
*   在一个代码块中有7个有效final变量和2个可变变量，可变变量的类型会在视觉上不和谐，破坏了该功能的大部分。
                
                    
     另一方面，我们可以扩展这个功能包括相当于空的final的局部变量（即：不需要初始化值，而是依靠明确的分配分析），我们选择
     限制为"仅适用初始化值的变量"，因为它涵盖了很大一部分候选项，同时保持功能的简单些并减少"action in distance"错误。
     
     同样地，
     
    
        






