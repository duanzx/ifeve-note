### 实例分析 Queue 和 BlockingQueue
> * Queue的主要实现类是ConcurrentLinkedQueue,它使用非阻塞算法(循环CAS)来实现同一时间只有一个线程操作队列。
首先看一段示例代码：
```
        @Test
        public void testForConcurrentLinkedQueue(){
            final ConcurrentLinkedQueue<Integer> concurrentLinkedQueue = new ConcurrentLinkedQueue<>();
            ThreadGroup addThreadGroup = new ThreadGroup("addThreadGroup");
            AtomicInteger count = new AtomicInteger();
            for(int i = 0;i<10;i++){
                new Thread(addThreadGroup,new Runnable() {
                    @Override
                    public void run() {
                        int ags = count.incrementAndGet();
                        int increment = 1;
                        for(int x = 0;x<ags;x++){
                            increment *= 10;
                        }
                        for(int i = 0;i<10;i++){
                            concurrentLinkedQueue.add(increment + i);
                        }
    
                    }
                }).start();
            }
            while (addThreadGroup.activeCount() > 0){
            }
            System.out.println(concurrentLinkedQueue.toString());
            ThreadGroup removeThreadGroup = new ThreadGroup("removeThreadGroup");
            final ConcurrentLinkedQueue<Integer> resultLinkedQueue = new ConcurrentLinkedQueue<>();
            for(int i = 0;i<10;i++){
                new Thread(removeThreadGroup, () -> {
                    for(int i1 = 0; i1 <10; i1++){
                        Integer value = concurrentLinkedQueue.poll();
                        if(null != value){
                            resultLinkedQueue.add(value);
                        }
                    }
    
                }).start();
            }
            while (removeThreadGroup.activeCount() > 0){
            }
            System.out.println(resultLinkedQueue.toString());
        }
```
> * 运行代码后发现，在多线程中写入顺序和读取顺序是一致的。接下来分析它的内部实现。
> 1. 分析ConcurrentLinkedQueue的创建                
ConcurrentLinkedQueue使用链表存储队列元素，在初始化的时候就是给head和tail节点进行赋值。另外值得注意是的是head和
tail都是用volatile修饰的，这样能够保证它们在各个线程中可见。      
``
      head = tail = new Node<E>();
``
> 2. 分析ConcurrentLinkedQueue的add()，add()方法内部是调用的offer()方法，它的主要实现如下：        
> * 根据传入元素创建Node节点对象，作为新的节点。    
      
> * 不考虑单线程的话添加节点很简单只需要: tail.next = n; tail = n，但是多线程环境下,每段程序执行后tail的状态
  都是对其它线程可见的。状态值的不同，则对应多线程处理的逻辑也不同。所以我们要在每个线程中循环检查tail的状态，直到 tail 节点更新成功。       
  
> * 当tail节点的next节点为空的时候，可以对tail节点执行插入，先执行CAS(p.next,null,newNode),执行成功后，如果是第一次
插入，则直接返回。如果是第二次插入，则执行CAS(tail,t,newNode);
> * 当tail.next节点不为空，c说明有其它线程正在对tail节点进行插入操作。如果其它线程只执行了一次插入操作，也就是只执行了
CAS(p.next,null,newNode),此时

使用t记住当前线程中tail的值，并赋值给p


```
     public boolean offer(E e) {
            //将e作为Node的item创建Node对象
            final Node<E> newNode = new Node<E>(Objects.requireNonNull(e));
            //将tail赋值给t变量记住当前线程中tail的状态，将t赋值给p,获取当前线程中tail节点。
            for (Node<E> t = tail, p = t;;) {
                Node<E> q = p.next; 
                //如果q == null,说明当前线程中的tail节点状态正确，执行插入更新
                if (q == null) {
                    // 如果p.next为null，则CAS(p.next,null,newNode) ， tail.next = newNode
                    if (NEXT.compareAndSet(p, null, newNode)) {
                        if (p != t) //第一次 p == t,第二次p != t ,此时更新一下tail ,tail = newNode,
                            TAIL.weakCompareAndSet(this, t, newNode);
                        return true;
                    }
                    // Lost CAS race to another thread; re-read next
                }
                else if (p == q)
                    //若 q != null && p == q ,说明有其它线程在插入节点（tail.next = newNode;tail = newNode)
                    //当其它节点插入成功后，当前线程的tail状态t 应该不等于其它线程总的新的tail状态 ， t ! (t = tail)
                    //此时应将p节点执行新的tail节点 p = (t = tail)
                    //当t == (t = tail)时候，说明tail节点始终没有插入成功，应该重置 p = head
                    p = (t != (t = tail)) ? t : head;
                else
                    //如果q != null && p != q ,说明tail节点已经插入成功，
                    //如果是其它线程更新的tail节点 p != t && t != (t = tail) ， 则将p指向新的节点 p = (t = tail)
                    //如果是当前线程第一次更新的tail节点，则将p指向q ,p =q
                    p = (p != t && t != (t = tail)) ? t : q;
            }
        }

```

> 3. 分析ConcurrentLinkedQueue的poll(),在单线程下，队列的出队操作是这样的，Node r = head.next; head= r;
假设队列的内容为：head -> n0 -> n1 -> tail；初始化队列时候 head = tail = new Node();head.item = null;
> * 由于在多线程中head的状态是可见的，所以也不断地循环检查head的状态，只有状态符合时，才允许更新head节点。
> * 设 h = head,p = h
> * 当p.item != null 时
用h = head，记住当前

```
    public E poll() {
            restartFromHead: for (;;) {
                for (Node<E> h = head, p = h, q;; p = q) {
                    final E item;
                    if ((item = p.item) != null && p.casItem(item, null)) {
                        // Successful CAS is the linearization point
                        // for item to be removed from this queue.
                        if (p != h) // hop two nodes at a time
                            updateHead(h, ((q = p.next) != null) ? q : p);
                        return item;
                    }
                    else if ((q = p.next) == null) {
                        updateHead(h, p);
                        return null;
                    }
                    else if (p == q)
                        continue restartFromHead;
                }
            }
        }
```



### 实例分析 ConcurrentHashMap

### 实例分析 CopyOnWriteArrayList